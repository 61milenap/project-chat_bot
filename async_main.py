from aiogram import Bot, Dispatcher, executor, types
import sqlite3
import random
import time
from get_message import send_message
#from pprint import pprint

with open("config.txt") as config:
    token = config.readline().strip()

with open("dictionary/words.txt", encoding="utf-8") as f_words:
    words = f_words.read().split("\n")

with open("dictionary/blackWords.txt", encoding="utf-8") as f_blackWords:
    blackWords = f_blackWords.read().split("\n")

bot = Bot(token=token)
dp = Dispatcher(bot)
db = sqlite3.connect("data.db")

# Create Cursor for db
cur = db.cursor()



def get_task(words_d, blackWords_d):
    s_words = set()
    s_black = set()
    while len(s_words) != 3:
        num = random.randrange(0, len(words_d) - 1)
        s_words.add(words[num])
    num = random.randrange(0, len(blackWords_d) - 1)
    s_black.add(blackWords[num])
    return s_words, s_black


def get_variant():
    s_words, s_black = get_task(words, blackWords)
    s_words = list(s_words)
    s_black = list(s_black)
    numWright = random.randrange(0, 3)
    answers = [''] * 4
    answers[numWright] = s_black[0]
    count = 0
    for j in s_words:
        if answers[count] == '':
            answers[count] = j
        else:
            count += 1
            answers[count] = j
        count += 1
    text = ""
    for j in range(len(answers)):
        text += f"{j + 1}) {answers[j]} \n"
    return text, numWright


def find_in_data(id_user):
    global cur
    res = cur.execute("SELECT * FROM users_info WHERE id = ?", (str(id_user), )).fetchall()

    return res != []

def keyboard_no_yes():
    keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    key_yes = types.InlineKeyboardButton(text='–î–∞', callback_data='–î–∞')
    key_no = types.InlineKeyboardButton(text='–ù–µ—Ç', callback_data='–ù–µ—Ç')
    keyboard.add(key_yes, key_no)
    return keyboard

def keyboard_answer():
    keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    key_1 = types.InlineKeyboardButton(text='1', callback_data='1')
    key_2 = types.InlineKeyboardButton(text='2', callback_data='2')
    keyboard.add(key_1, key_2)
    key_3 = types.InlineKeyboardButton(text='3', callback_data='3')
    key_4 = types.InlineKeyboardButton(text='4', callback_data='4')
    keyboard.add(key_3, key_4)
    return keyboard

@dp.message_handler(commands="start")
async def start(message: types.Message):
    if not find_in_data(message.from_user.id):
        id_user = message.from_user.id
        score = 0
        temp = 0
        num = -1
        activity = 0
        first_name = message.from_user.first_name
        last_name = message.from_user.last_name
        cur.execute("INSERT INTO users_info VALUES (?, ?, ?, ?, ?, ?, ?)", (str(id_user), score, temp, num, activity, first_name, last_name))
        send_message(f"{first_name} –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è –≤ –≤–∞—à–µ–º –±–æ—Ç–µ!")
        db.commit()
    activity = 0
    temp = 0
    num = -1
    cur.execute("UPDATE users_info SET activity = ?, temp = ?, num = ? WHERE id = ?", (activity, temp, num, message.from_user.id))
    db.commit()
    text = f"üñêüèæ –ü—Ä–∏–≤–µ—Ç, <b>{message.from_user.first_name}</b>.\n–ù–∞—á–∞—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É?"
    keyboard = keyboard_no_yes()
    await message.answer(text, parse_mode="html", reply_markup=keyboard)


@dp.message_handler(commands="record")
async def record(message: types.Message):
    if not find_in_data(str(message.from_user.id)):
        text = f"–í–∞—Å –Ω–µ—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö! –ù–∞–∂–º–∏—Ç–µ –Ω–∞ /start, {message.from_user.id.first_name}"
        await message.answer(text, parse_mode="html")
        return
    record = int(cur.execute("SELECT score FROM users_info WHERE id = ?", (str(message.from_user.id), )).fetchall()[0][0])
    text = f"üèãüèø‚Äç‚ôÄÔ∏è –í–∞—à —Ä–µ–∫–æ—Ä–¥: {record}"
    await message.answer(text, parse_mode="html")


@dp.message_handler(commands="users")
async def users(message: types.Message):
    res = cur.execute("SELECT * FROM users_info").fetchall() 
    text = f"üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(res)}"
    await message.answer(text, parse_mode="html")


@dp.message_handler(commands="update")
async def update(message: types.Message):
    cur.execute("UPDATE users_info SET first_name = ?, last_name = ? WHERE id = ?", (message.from_user.first_name, message.from_user.last_name, message.from_user.id))
    db.commit()
    text = f"üòâ –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–æ!"
    await message.answer(text, parse_mode="html")


@dp.message_handler(commands="leaderboard")
async def leaderboard(message: types.Message):
    leader_board = cur.execute("SELECT first_name, last_name, score FROM users_info ORDER BY score DESC").fetchmany(10)
    text = "üèÜ –¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤:\n\n"
    num = 0
    for j in leader_board:
        num += 1
        first_name, last_name, score = j
        if num == 1:
            text += "ü•á "
        elif num == 2:
            text += "ü•à "
        elif num == 3:
            text += "ü•â "
        else:
            text += f" {num}. "
        if last_name != None:
            text += f"{first_name} {last_name} ‚Äî {score}\n"
        else:
            text += f"{first_name} ‚Äî {score}\n"
    await message.answer(text, parse_mode="html")

@dp.message_handler()
async def training(message: types.Message):
    if not find_in_data(str(message.from_user.id)):
        text = f"–í–∞—Å –Ω–µ—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö! –ù–∞–∂–º–∏—Ç–µ –Ω–∞ /start, {message.from_user.first_name}"
        await message.answer(text, parse_mode="html")
        return
    activity = int(cur.execute("SELECT activity FROM users_info WHERE id = ?", (str(message.from_user.id), )).fetchall()[0][0])
    if activity:
        activity = 0
        num = int(cur.execute("SELECT num FROM users_info WHERE id = ?", (str(message.from_user.id), )).fetchall()[0][0])
        temp = int(cur.execute("SELECT temp FROM users_info WHERE id = ?", (str(message.from_user.id), )).fetchall()[0][0])
        score = int(cur.execute("SELECT score FROM users_info WHERE id = ?", (str(message.from_user.id), )).fetchall()[0][0])
        if any(message.text == x for x in ["1", "2", "3", "4"]):
            if message.text == str(num + 1):
                temp += 1
                if temp > score:
                    score = temp
                num = -1
                text = f"‚úÖ <b>–í–µ—Ä–Ω–æ!</b> –ñ–µ–ª–∞–µ—Ç–µ –ª–∏ –≤—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –¥–∞–ª—å—à–µ?\n<b>score:{temp}</b>"
                keyboard = keyboard_no_yes()
                cur.execute("UPDATE users_info SET activity = ?, num = ?, temp = ?, score = ? WHERE id = ?", (activity, num, temp, score, str(message.from_user.id)))
                db.commit()
                await message.answer(text, parse_mode="html", reply_markup=keyboard)

            else:
                if temp > score:
                    score = temp
                temp = 0
                text = f"‚ùå <b>–ù–ï–í–ï–†–ù–û! </b>\n –ñ–µ–ª–∞–µ—Ç–µ –ª–∏ –≤—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ?"
                keyboard = keyboard_no_yes()
                num = -1
                cur.execute("UPDATE users_info SET activity = ?, num = ?, temp = ?, score = ? WHERE id = ?", (activity, num, temp, score, str(message.from_user.id)))
                db.commit()
                await message.answer(text, parse_mode="html", reply_markup=keyboard)
        else:
            keyboard = keyboard_answer()
            await message.answer(
                         f"üò° –Ø —Ç–µ–±—è –Ω–µ –ø–æ–Ω–∏–º–∞—é, –¥—Ä—É–∂–∏—â–µ. –°–æ–±–µ—Ä–∏—Ç–µ—Å—å, <b>{message.from_user.first_name}</b>",
                         parse_mode="html", reply_markup=keyboard)
    elif message.text == "–î–∞" or message.text == "–î–∞–ª–µ–µ" and not activity:
        activity = 1
        keyboard = keyboard_answer()
        text, num = get_variant()
        question = "üïµüèø –£–∫–∞–∂–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç –æ—Ç–≤–µ—Ç–∞, –≥–¥–µ —É–¥–∞—Ä–µ–Ω–∏–µ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–æ <b>–Ω–µ–≤–µ—Ä–Ω–æ</b>\n"
        text = question + text
        cur.execute("UPDATE users_info SET activity = ?, num = ? WHERE id = ?", (activity, num, str(message.from_user.id)))
        db.commit()
        await message.answer(text, parse_mode="html", reply_markup=keyboard)
    elif message.text == "–ù–µ—Ç":
        keyboard = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
        key_start = types.InlineKeyboardButton(text='/start', callback_data='/start')
        keyboard.add(key_start)
        text = "üò≥ –•–æ—Ä–æ—à–æ, –Ω–æ –∑–∞–¥—É–º–∞–π—Å—è –Ω–∞–¥ –ø–æ—Å–ª–æ–≤–∏—Ü–µ–π:\n–®–µ–≤–µ–ª–∏ —Ä–∞–Ω—å—à–µ <b>–º–æ–∑–≥–∞–º–∏</b>, –∞ —Ç–æ –ø–æ–ø–ª–∞—Ç–∏—à—å—Å—è <b>—â–µ–∫–∞–º–∏</b>."
        await message.answer(text, parse_mode="html", reply_markup=keyboard)
    else:
        await message.answer(
                         f"üò° –Ø —Ç–µ–±—è –Ω–µ –ø–æ–Ω–∏–º–∞—é, –¥—Ä—É–∂–∏—â–µ. –°–æ–±–µ—Ä–∏—Ç–µ—Å—å, <b>{message.from_user.first_name}</b>",
                         parse_mode="html")


#while True:
#    try:
executor.start_polling(dp, skip_updates=True)
#    except Exception as e:
#        send_message(e)
#        time.sleep(15)
db.close()